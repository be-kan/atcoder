#include <algorithm>#include <iostream>#include <iomanip>#include <cstring>#include <string>#include <vector>#include <random>#include <queue>#include <cmath>#include <stack>#include <set>#include <map>typedef long long ll;using namespace std;using ull = unsigned long long;random_device rnd;mt19937 mt(rnd());ll mod_pow(ll x, ll n, ll mod) {    if (n <= 0) return 1;    ll tmp = mod_pow(x, n / 2, mod);    return tmp * tmp % mod * (n % 2 ? x : 1) % mod;}bool is_prime(ll n, int times = 50) {    if (n == 2) return true;    if (n % 2 == 0 || n < 2) return false;    ll d = n - 1;    while (d % 2 == 0) d /= 2;    while (times--) {        ll a = rnd() % (n - 2) + 1;        ll t = d;        ll y = mod_pow(a, t, n);        while (t != n - 1 && y != 1 && y != n - 1) { y = y * y % n; t *= 2; }        if (y != n - 1 && t % 2 == 0) return false;    }    return true;}ll gen_prime() {    while (1) {        ll n = mt();        if (n == 1) continue;        if (is_prime(n)) return n;    }}class RollingHash {public:    vector <ull> hash, pows;    ull base, mod;    RollingHash(const string& S, ull base = gen_prime(), ull m = gen_prime()) : hash(S.size() + 1), pows(S.size() + 1), mod(m) {        pows[0] = 1;        for (int i = 0; i < S.size(); i++) {            pows[i+1] = pows[i] * base % mod;            hash[i+1] = hash[i] * base % mod + S[i];            hash[i+1] %= mod;        }    }    // [l, r)    ull get(int l, int r) {        assert(l <= r);        ull ret = hash[r] + mod - hash[l] * pows[r - l] % mod;        ret %= mod;        return ret;    }};int main() {    return 0;}