#include <iostream>#include <vector>#include <map>using namespace std;typedef long long ll;class RollingHash {    const ll base = 9973;    const vector <ll> mod = {999999937LL, 1000000007LL};    string S;    vector <ll> hash[2], pow[2];public:    RollingHash(const string &s) {        S = s;        int n = S.size();        for (int i = 0; i < 2; i++) {            hash[i].assign(n + 1, 0);            pow[i].assign(n + 1, 1);            for (int j = 0; j < n; j++) {                hash[i][j + 1] = (hash[i][j] * base + S[j]) % mod[i];                pow[i][j + 1] = pow[i][j] * base % mod[i];            }        }    }    // get hash of S[l:r)    ll get(int l, int r, int id = 1) {        ll res = hash[id][r] - hash[id][l] * pow[id][r - l] % mod[id];        if (res < 0) res += mod[id];        return res;    }};// verified//   http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_B&lang=jpvoid AOJ_ALDS1_14_B() {    string T, P;    cin >> T >> P;    RollingHash rh1(T), rh2(P);    for (int i = 0; i + P.size() <= T.size(); i++) {        if (rh1.get(i, i + P.size()) == rh2.get(0, P.size())) {            cout << i << "\n";        }    }}// verified//   https://yukicoder.me/problems/no/430//   mod = 999999937LL だとハッシュが衝突してWAだったvoid yuki430() {    string S, C;    int M;    cin >> S >> M;    RollingHash rh(S);    map <ll, int> mp;    for (int l = 0; l < S.size(); l++) {        for (int r = 1; r <= 10; r++) {            if (l + r > S.size()) continue;            mp[rh.get(l, l + r)]++;        }    }    int ans = 0;    for (int m = 0; m < M; m++) {        cin >> C;        RollingHash rh1(C);        ans += mp[rh1.get(0, C.size())];    }    cout << ans << "\n";}// verified//   https://yukicoder.me/problems/no/599const ll MOD = 1000000007LL;vector <ll> dp(100005);vector <bool> used(100005, false);ll dfs(RollingHash &rh, int L, int R) {    if (R <= L) return 1;    if (used[L]) return dp[L];    ll ret = 1;    int l = L + 1, r = R - 1;    while (l <= r) {        if (rh.get(L, l) == rh.get(r, R)) {            ret = (ret + dfs(rh, l, r)) % MOD;        }        l++; r--;    }    used[L] = true;    return dp[L] = ret;}void yuki599() {    string S;    cin >> S;    RollingHash rh(S);    cout << dfs(rh, 0, S.size()) << "\n";}int main() {    // AOJ_ALDS1_14_B();    // yuki430();    yuki599();    return 0;}